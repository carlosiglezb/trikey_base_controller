#!/usr/bin/env python3

import rospy
import tf2_ros
import tf
from tf.transformations import euler_from_quaternion, quaternion_from_euler
from nav_msgs.msg import Odometry
from std_msgs.msg import Float64
from geometry_msgs.msg import Twist


class OdomFilter():
    def __init__(self):
        

        # Read parameters from ROS server
        self.raw_odom = rospy.get_param('/raw_odom_topic')
        self.filtered_odom = rospy.get_param('/filtered_odom_topic')
        self.alpha = rospy.get_param('/odom_lpf/alpha')
        self.publish_filtered_odom_tf = rospy.get_param('/publish_filtered_odom_tf', True)

 
        # Subscribe RTABmap odom topic
        rospy.Subscriber(self.raw_odom, Odometry, self.odom_callback)
        # Publisher for filtered odom
        self.odom_pub = rospy.Publisher(self.filtered_odom, Odometry, queue_size=10)
        # TF broadcaster for filtered odom
        self.tf_br = tf2_ros.TransformBroadcaster()

        # Publisher for LPF coefficient, alpha
        self.alpha_pub = rospy.Publisher("/alpha", Float64, queue_size=10)

        # Subscriber for LPF coefficient, alpha
        rospy.Subscriber("/alpha", Float64, self.alpha_callback)

        # Initialize Odom msg
        self.prev_msg = Odometry()

        # Initialize TF 
        self.tf = tf2_ros.TransformStamped()


    def alpha_callback(self, msg):
        """
        Callback function for alpha subscriber

        Args
        ------------------------------------------------
            + alpha: filter coefficient
        """
        self.alpha = msg.data
        # Publish alpha to topic
        self.alpha_pub.publish(self.alpha)

    def odom_callback(self, msg):
        
        # Low pass filter to odom msg
        msg = self.LPF(msg,self.alpha)
        # Publish filtered odom
        self.odom_pub.publish(msg)

        if self.publish_filtered_odom_tf:
            # Broadcast TF from filtered odom to base_link
            self.broadcastTF(msg)
      
        

    def LPF(self, msg, alpha=0.5):
        """
        Low pass filter for odometry

        Args
        ------------------------------------------------ 
            + Raw Odometry Topic <nav_msgs.msg.Odometry>
            + alpha: filter coefficient


        Return: 
        ------------------------------------------------
            + Filtered Odometry Topic <nav_msgs.msg.Odometry>
        """

        # Filter linear velocity


        msg.twist.twist.linear.x = alpha*msg.twist.twist.linear.x + (1-alpha)*self.prev_msg.twist.twist.linear.x
        msg.twist.twist.linear.y = alpha*msg.twist.twist.linear.y + (1-alpha)*self.prev_msg.twist.twist.linear.y
        msg.twist.twist.linear.z = 0
        # Filter angular velocity
        msg.twist.twist.angular.x = 0
        msg.twist.twist.angular.y = 0
        msg.twist.twist.angular.z = alpha*msg.twist.twist.angular.z + (1-alpha)*self.prev_msg.twist.twist.angular.z
        # Filter position
        msg.pose.pose.position.x = alpha*msg.pose.pose.position.x + (1-alpha)*self.prev_msg.pose.pose.position.x
        msg.pose.pose.position.y = alpha*msg.pose.pose.position.y + (1-alpha)*self.prev_msg.pose.pose.position.y
        msg.pose.pose.position.z = 0
        
        # Filter orientation
        # orientation_list = [msg.pose.pose.orientation_q.x, 
        #                     msg.pose.pose.orientation_q.y, 
        #                     msg.pose.pose.orientation_q.z, 
        #                     msg.pose.pose.orientation_q.w]
        # (roll, pitch, yaw) = euler_from_quaternion (orientation_list)

        # filtered_roll = alpha*roll + (1-alpha)*self.prev_roll
        # filtered_pitch = alpha*pitch + (1-alpha)*self.prev_pitch
        # filtered_yaw = alpha*yaw + (1-alpha)*self.prev_yaw

        # filtered_orientation_q = quaternion_from_euler(filtered_roll, filtered_pitch, filtered_yaw)
  
 


        # # Update the orientation in the message
        # msg.pose.pose.orientation.x = filtered_orientation_q[0]
        # msg.pose.pose.orientation.y = filtered_orientation_q[1]
        # msg.pose.pose.orientation.z = filtered_orientation_q[2]
        # msg.pose.pose.orientation.w = filtered_orientation_q[3]

        # # Update the previous Euler angles
        # self.prev_roll = filtered_roll
        # self.prev_pitch = filtered_pitch
        # self.prev_yaw = filtered_yaw

        # Update old msg
        self.prev_msg = msg

    

        return msg
    
    def broadcastTF(self,msg):
        """
        Broadcast TF from filtered odom to base_link

        Args
        ------------------------------------------------
            + Filtered Odometry Topic <nav_msgs.msg.Odometry>
        """
        self.tf.header.stamp = rospy.Time.now()
        self.tf.header.frame_id = "odom"
        self.tf.child_frame_id = "base_link"
        self.tf.transform.translation.x = msg.pose.pose.position.x
        self.tf.transform.translation.y = msg.pose.pose.position.y
        self.tf.transform.translation.z = msg.pose.pose.position.z
        self.tf.transform.rotation.x = msg.pose.pose.orientation.x
        self.tf.transform.rotation.y = msg.pose.pose.orientation.y
        self.tf.transform.rotation.z = msg.pose.pose.orientation.z
        self.tf.transform.rotation.w = msg.pose.pose.orientation.w
        self.tf_br.sendTransform(self.tf)
        


  
if __name__ == '__main__':
    #  Initialize node
    rospy.init_node('odom_lpf', anonymous=True)
    # Initialize OdomFilter class
    odom_filter = OdomFilter()
    # Keep node running
    rospy.spin()
