#!/usr/bin/env python3

import rospy
import tf2_ros
import tf
from tf.transformations import euler_from_quaternion, quaternion_from_euler
from nav_msgs.msg import Odometry
from std_msgs.msg import Float64
from geometry_msgs.msg import Twist


class OdomFilter():
    def __init__(self):
        

        # Read parameters from ROS server
        self.raw_odom = rospy.get_param('/odom_lpf/raw_odom_topic', '/odom_icp')
        self.filtered_odom = rospy.get_param('/odom_lpf/filtered_odom_topic','/odom_icp_filtered')
        self.alpha = rospy.get_param('odom_lpf/lpf_alpha',0.1)
        self.publish_filtered_odom_tf = rospy.get_param('/odom_lpf/publish_filtered_tf', True)
        self.base_frame_id = rospy.get_param('/odom_lpf/base_frame_id', 'base_link')
        self.filtered_odom_frame_id = rospy.get_param('/odom_lpf/filtered_odom_frame_id','odom_icp_filtered')

 
        # Subscribe RTABmap odom topic
        rospy.Subscriber(self.raw_odom, Odometry, self.odom_callback)
        # Publisher for filtered odom
        self.odom_pub = rospy.Publisher(self.filtered_odom, Odometry, queue_size=10)
        # TF broadcaster for filtered odom
        self.tf_br = tf2_ros.TransformBroadcaster()

        # Publisher for LPF coefficient, alpha
        self.alpha_pub = rospy.Publisher("/alpha", Float64, queue_size=10)

        # Subscriber for LPF coefficient, alpha
        rospy.Subscriber("/alpha", Float64, self.alpha_callback)

        # Initialize Odom msg
        self.prev_msg = Odometry()

        # Initialize TF 
        self.tf = tf2_ros.TransformStamped()


    def alpha_callback(self, msg):
        """
        Callback function for alpha subscriber

        Args
        ------------------------------------------------
            + alpha: filter coefficient
        """
        self.alpha = msg.data
        # Publish alpha to topic
        self.alpha_pub.publish(self.alpha)

    def odom_callback(self, msg):
        
        # Low pass filter to odom msg
        msg = self.LPF(msg,self.alpha)
        # Publish filtered odom
        self.odom_pub.publish(msg)

        if self.publish_filtered_odom_tf:
            # Broadcast TF from filtered odom to base_link
            self.broadcastTF(msg)
      
        

    def LPF(self, msg, alpha):
        """
        Low pass filter for odometry

        Args
        ------------------------------------------------ 
            + Raw Odometry Topic <nav_msgs.msg.Odometry>
            + alpha: filter coefficient


        Return: 
        ------------------------------------------------
            + Filtered Odometry Topic <nav_msgs.msg.Odometry>
        """

        # Filter linear velocity


        msg.twist.twist.linear.x = alpha*msg.twist.twist.linear.x + (1-alpha)*self.prev_msg.twist.twist.linear.x
        msg.twist.twist.linear.y = alpha*msg.twist.twist.linear.y + (1-alpha)*self.prev_msg.twist.twist.linear.y
        msg.twist.twist.linear.z = 0
        # Filter angular velocity
        msg.twist.twist.angular.x = 0
        msg.twist.twist.angular.y = 0
        msg.twist.twist.angular.z = alpha*msg.twist.twist.angular.z + (1-alpha)*self.prev_msg.twist.twist.angular.z
        # Filter position
        msg.pose.pose.position.x = alpha*msg.pose.pose.position.x + (1-alpha)*self.prev_msg.pose.pose.position.x
        msg.pose.pose.position.y = alpha*msg.pose.pose.position.y + (1-alpha)*self.prev_msg.pose.pose.position.y
        msg.pose.pose.position.z = 0
        
        # Filter orientation
        # Convert quaternion to euler
        (roll, pitch, yaw) = euler_from_quaternion([msg.pose.pose.orientation.x, msg.pose.pose.orientation.y, msg.pose.pose.orientation.z, msg.pose.pose.orientation.w])
        # Filter yaw for 2D motion
        yaw = alpha*yaw + (1-alpha)*euler_from_quaternion([self.prev_msg.pose.pose.orientation.x, self.prev_msg.pose.pose.orientation.y, self.prev_msg.pose.pose.orientation.z, self.prev_msg.pose.pose.orientation.w])[2]
        pitch = 0 
        roll = 0
        # Convert euler to quaternion
        q = quaternion_from_euler(roll, pitch, yaw)
        msg.pose.pose.orientation.x = q[0]
        msg.pose.pose.orientation.y = q[1]
        msg.pose.pose.orientation.z = q[2]
        msg.pose.pose.orientation.w = q[3]

    
        # Update old msg
        self.prev_msg = msg

    

        return msg
    
    def broadcastTF(self,msg):
        """
        Broadcast TF from filtered odom to base_link

        Args
        ------------------------------------------------
            + Filtered Odometry Topic <nav_msgs.msg.Odometry>
        """
        self.tf.header.stamp = rospy.Time.now()
        self.tf.header.frame_id = self.filtered_odom_frame_id
        self.tf.child_frame_id = self.base_frame_id
        self.tf.transform.translation.x = msg.pose.pose.position.x
        self.tf.transform.translation.y = msg.pose.pose.position.y
        self.tf.transform.translation.z = msg.pose.pose.position.z
        self.tf.transform.rotation.x = msg.pose.pose.orientation.x
        self.tf.transform.rotation.y = msg.pose.pose.orientation.y
        self.tf.transform.rotation.z = msg.pose.pose.orientation.z
        self.tf.transform.rotation.w = msg.pose.pose.orientation.w
        self.tf_br.sendTransform(self.tf)
        


  
if __name__ == '__main__':
    #  Initialize node
    rospy.init_node('odom_lpf', anonymous=True)
    # Initialize OdomFilter class
    odom_filter = OdomFilter()
    # Keep node running
    rospy.spin()
